#!/usr/bin/env
"""
A script to convert a SMILES string into a pre-optimised Gaussian input file using RDKit.
This file pre-optimises the structure using UFF and generates a Gaussian input (.gjf) file.

Example usage: python3 smiles2gjf.py -s "C1=CC=CC=C1" -o benzene.gjf
"""

import argparse

from rdkit import Chem
from rdkit.Chem import AllChem

# Dictionary of custom headers. Once my workflow is more clear, I can write a few options here.
CUSTOM_HEADERS = {
    "default": (
        "%NProcShared=4\n"
        "%Mem=4GB\n"
        "#P B3LYP/6-31G(d) Opt Freq\n\n"
        "Generated by RDKit\n\n"
        "{charge_mult}\n"
    ),
    "advanced": (
        "%NProcShared=4\n"
        "%Mem=8GB\n"
        "#P B3LYP/6-311+G(d,p) Opt Freq\n\n"
        "Advanced B3LYP calculation\n\n"
        "{charge_mult}\n"
    ),
    "pbe0": (
        "%NProcShared=4\n"
        "%Mem=4GB\n"
        "#P PBE0/6-31G(d) Opt Freq\n\n"
        "PBE0 calculation\n\n"
        "{charge_mult}\n"
    ),
    "wb97xd_def2tzvp": (
        "#P wb97xd/def2TZVP Opt Freq Int(Grid=UltraFine)\n\n"
        "Opt+Freq ωB97X-D/def2-TZVP\n\n"
        "{charge_mult}\n"
    ),
    "dsd_def2qzvp": (
        "#P dsdpbep86/def2QZVP EmpiricalDispersion=GD3BJ "
        "Guess=Read Geom=AllCheck\n\n"
        "SP DSD-PBEP86/def2-QZVP\n\n"
        "{charge_mult}\n"
    ),
}


def smiles_to_gjf(smiles, out_path, nproc, mem, charge_mult):
    # Convert SMILES → RDKit mol, embed + MMFF conformer
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError(f"Invalid SMILES: '{smiles}'")
    mol = Chem.AddHs(mol)
    AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
    AllChem.MMFFOptimizeMolecule(mol)

    # Ensure filename ends in .gjf
    if not out_path.endswith(".gjf"):
        out_path = out_path + ".gjf"
    chk = out_path.replace(".gjf", ".chk")

    with open(out_path, "w") as f:
        # --- Link1 Section 1: Geometry optimization + frequency ---
        f.write(f"%NProcShared={nproc}\n")
        f.write(f"%Mem={mem}\n")
        f.write(f"%Chk={chk}\n")
        f.write(CUSTOM_HEADERS["wb97xd_def2tzvp"].format(charge_mult=charge_mult))
        # Write geometry block
        for atom in mol.GetAtoms():
            pos = mol.GetConformer().GetAtomPosition(atom.GetIdx())
            f.write(
                f"{atom.GetSymbol():2}  {pos.x:12.6f}  {pos.y:12.6f}  {pos.z:12.6f}\n"
            )
        f.write("\n--Link1--\n")
        # --- Link1 Section 2: Single‐point refinement ---
        f.write(f"%NProcShared={nproc}\n")
        f.write(f"%Mem={mem}\n")
        f.write(f"%Chk={chk}\n")
        f.write(CUSTOM_HEADERS["dsd_def2qzvp"].format(charge_mult=charge_mult))
        # Blank line after charge/multiplicity (no coordinates needed)
        f.write("\n")


def main():
    parser = argparse.ArgumentParser(
        description="Convert a SMILES string into a two‐stage Gaussian .gjf file"
    )
    parser.add_argument(
        "-s",
        "--smiles",
        required=True,
        help="Input SMILES string (enclose in quotes if needed)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="molecule.gjf",
        help="Output .gjf filename (default: molecule.gjf)",
    )
    parser.add_argument(
        "--nproc",
        type=int,
        default=6,
        help="Number of cores for Gaussian (%NProcShared) (default: 6)",
    )
    parser.add_argument(
        "--mem",
        default="8GB",
        help="Memory for Gaussian (%Mem), e.g. '8GB' (default: 8GB)",
    )
    parser.add_argument(
        "--charge-mult", default="0 1", help="Charge and multiplicity (default: '0 1')"
    )
    args = parser.parse_args()

    smiles_to_gjf(
        smiles=args.smiles,
        out_path=args.output,
        nproc=args.nproc,
        mem=args.mem,
        charge_mult=args.charge_mult,
    )
    print(f"Gaussian input written to {args.output}")


if __name__ == "__main__":
    main()
